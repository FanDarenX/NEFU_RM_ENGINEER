#include "VMC.h"
#include "arm_math.h"
#include "gimbal_task.h"
#include "user_lib.h"
#define ABS(x) (((x) > 0) ? (x) : (-(x)))
/*
//VMC解算函数
//日期：2022/11/1
//只写了运动学正解求 轮子末端位置
//2022/11/21纠正严重bug
*/



void Forward_kinematic_solution(chassis_control_t *feedback_update,
                                fp32 Q1,fp32 S1,fp32 Q4,fp32 S4,fp32 A1,fp32 A4,uint8_t ce)	//ce 1为L 0为R
{

    fp32 dL0=0,L0=0,Q0=0,S0=0;
    fp32 xb,xd,yb,yd,Lbd,xc,yc;
    fp32 A0,B0,C0,Q2,Q3,S2,S3;
    fp32 vxb,vxd,vyb,vyd,vxc,vyc;
    fp32 cos_Q1,cos_Q4,sin_Q1,sin_Q4;
    fp32 sin_Q2,cos_Q2,sin_Q3,cos_Q3;
    fp32 axb,ayb,axd,ayd,a2,axc;
    /******************************/
    Q1 = PI + Q1;
    cos_Q1 = arm_cos_f32(Q1);
    sin_Q1 = arm_sin_f32(Q1);
    cos_Q4 = arm_cos_f32(Q4);
    sin_Q4 = arm_sin_f32(Q4);
    xb = -L5/2 + L1*cos_Q1;
    xd = L5/2  + L4*cos_Q4;
    yb = L1*sin_Q1;
    yd = L4*sin_Q4;

    //arm_sqrt_f32((xd-xb)*(xd-xb)+(yd-yb)*(yd-yb),&Lbd);
    Lbd=Sqrt((xd-xb)*(xd-xb)+(yd-yb)*(yd-yb));
    A0 = 2*L2*(xd-xb);
    B0 = 2*L2*(yd-yb);
    C0 = L2*L2+Lbd*Lbd-L3*L3;
    Q2 = 2 *atan_tl((B0+Sqrt(A0*A0 + B0*B0 -C0*C0))/(A0+C0));  //我他妈才发现在这里以前一个括号写错了，正逆解对不上，腿动的不正常――――2022/11/21

    xc = xb + arm_cos_f32(Q2)*L2;
    yc = yb + arm_sin_f32(Q2)*L2;
//	arm_sqrt_f32(xc*xc +yc*yc,&L0);
    L0=Sqrt(xc*xc +yc*yc);
    Q0 = atan_tl(yc/xc);

    // S1 A电机的角速度 S4 E电机的角速度
    vxb = -S1*L1*sin_Q1;
    vyb = S1*L1*cos_Q1;
    vxd = -S4*L4*sin_Q4;
    vyd = S4*L4*cos_Q4;
    Q3 = atan((yc-yd)/(xc-xd));
    S2 = ((vxd-vxb)*arm_cos_f32(Q3) + (vyd-vyb)*arm_sin_f32(Q3))/(L2*arm_sin_f32(Q3-Q2));
    S3 = ((vxd-vxb)*arm_cos_f32(Q2) + (vyd-vyb)*arm_sin_f32(Q2))/(L2*arm_sin_f32(Q3-Q2));
    vxc = vxb - S2*L2*arm_sin_f32(Q2);
    vyc = vyb + S2*L2*arm_cos_f32(Q2);
    S0 = 3*(-arm_sin_f32(ABS(Q0))*vxc-arm_cos_f32(Q0)*vyc);
		
//	//求解末端加速度//
//	//求b，d的加速度
//	axb=- L1*sin_Q1*A1 - L1*cos_Q1*A1*A1;
//	ayb=  L1*cos_Q1*A1 - L1*sin_Q1*A1*A1;
// 	axd=- L4*sin_Q4*A4 - L4*cos_Q4*A4*A4;
//	ayd=  L4*cos_Q4*A4 - L4*sin_Q4*A4*A4;
//	//求双膝盖角加速度
//	a2 = (axd=axb)*arm_cos_f32(Q3) + (ayd-ayb)*arm_sin_f32(Q3) + L2*S2*S2*arm_cos_f32(Q3-Q2) - S3*S3*L3;
//	//求末端速度
//	axc=axb-a2*L2*arm_sin_f32(Q2)-a2*a2*L2*arm_cos_f32(Q2);
    //ayc=ayb+a2*L2*arm_cos_f32(Q2)-a2*a2*L2*arm_sin_f32(Q2);

    if(Q0<0)Q0+=PI;
    /*******************************/
    if (ce)
    {
        feedback_update->chassis_balance .leg_length_L =L0;
        feedback_update->chassis_balance .leg_angle_L  =Q0;
        feedback_update->chassis_balance .leg_gyro_L   =S0;
//		feedback_update->chassis_balance.leg_gyro_L_ax    =vxc;
    }
    else
    {
        feedback_update->chassis_balance .leg_length_R =L0;
        feedback_update->chassis_balance .leg_angle_R  =Q0;
        feedback_update->chassis_balance .leg_gyro_R   =S0;
//		feedback_update->chassis_balance.leg_gyro_R_ax    =vxc;
    }
}
/****************************************************************************************/
void inverse_kinematics(chassis_control_t *feedback_update,fp32 angle,fp32 high,uint8_t ce)	//ce 1为L 0为R
{
    fp32 yc,xc;
    fp32 A,B,C,T[2];
    fp32 ya=0,xa=-L5/2;
    fp32 q1,q4;
    fp32 temp;
    for(uint8_t i=0; i<2; i++)
    {
        if(i==0)
        {
            ya=0,xa=-L5/2;
        }
        else
        {
            ya=0,xa=L5/2;
        }
        yc = high;
        //xc = tan(angle-PI_2)*high;
        xc = (arm_sin_f32(angle-PI/2)/arm_cos_f32(angle-PI/2))*high;
        A=(xc-xa)*(xc-xa) + (yc - ya)*(yc - ya) +L1*L1 - L2*L2;
        B=-2*(xc - xa)*L1;
        C=-2*(yc - ya)*L1;
        temp=Sqrt(C*C+B*B-A*A);
        //arm_sqrt_f32(C*C+B*B-A*A,&temp);
        if(i==0)
        {   T[0]=(-C+temp)/(A-B);
            q1 = 2*atan(T[0]);
        }
        else
        {   T[1]=(-C-temp)/(A-B);
            q4 = 2*atan(T[1]);
        }
    }

    if(ce==1)
    {
        feedback_update->unterleib_motor1 .position_set =q1-PI;
        if(feedback_update->unterleib_motor1 .position_set <-PI)
            feedback_update->unterleib_motor1 .position_set +=2*PI;

        feedback_update->unterleib_motor2 .position_set =q4;

        if(feedback_update->unterleib_motor1 .position_set>0.1f)feedback_update->unterleib_motor1 .position_set=0.1f;
        if(feedback_update->unterleib_motor2 .position_set<-0.1f)feedback_update->unterleib_motor2.position_set=-0.1f;

    }
    else
    {
        feedback_update->unterleib_motor4 .position_set =-PI+q1;
        if(feedback_update->unterleib_motor4 .position_set <-PI)
            feedback_update->unterleib_motor4 .position_set +=2*PI;
        feedback_update->unterleib_motor4 .position_set =-feedback_update->unterleib_motor4 .position_set ;
        feedback_update->unterleib_motor3 .position_set =-q4;

        if(feedback_update->unterleib_motor3 .position_set>0.1f)feedback_update->unterleib_motor3 .position_set=0.1f;
        if(feedback_update->unterleib_motor4 .position_set<-0.1f)feedback_update->unterleib_motor4.position_set=-0.1f;

    }
}

fp32 VMC_solve_J1(fp32 a,fp32 h)
{
    fp32 p00 =  0.1811  ;
    fp32 p10 =      -0.806;
    fp32 p01 =      -3.318;
    fp32 p20 =      -3.349 ;
    fp32 p11 =       5.656 ;
    fp32 p02 =       14.27 ;
    fp32 p30 =       18.45 ;
    fp32 p21 =       25.31;
    fp32 p12 =      -15.34 ;
    fp32 p03 =      -29.33;
    fp32 p40 =      -3.331;
    fp32 p31 =      -69.46;
    fp32 p22 =       -40.4 ;
    fp32 p13 =       16.87 ;
    fp32 p04 =       27.79 ;
    fp32 J1;
    fp32 x=0;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.12f;
    else if(h>0.3)h=0.3;
    J1 = (p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
          + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
          + p13*x*h*h*h + p04*h*h*h*h);
    return J1;
}
fp32 VMC_solve_invJ1(fp32 a,fp32 h)
{
    fp32 p00 =      -46.51 ;
    fp32 p10 =       252.6 ;
    fp32 p01 =       666.4  ;
    fp32 p20 =      -16.46 ;
    fp32 p11 =       -3169 ;
    fp32 p02 =       -4117 ;
    fp32 p30 =       -1346 ;
    fp32 p21 =       269.9 ;
    fp32 p12 =   1.358e+04 ;
    fp32 p03 =    1.17e+04 ;
    fp32 p40 =       582.5 ;
    fp32 p31 =        5547 ;
    fp32 p22 =       -1170 ;
    fp32 p13 =  -1.986e+04 ;
    fp32 p04 =  -1.287e+04 ;

    fp32 J1;
    fp32 x=0;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.3;
    else if(h>0.3)h=0.3;
    J1 = (p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
          + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
          + p13*x*h*h*h + p04*h*h*h*h);
    return J1;
}
fp32 VMC_solve_J2(fp32 a,fp32 h)
{
    fp32 p00 =  -0.1751f ;
    fp32 p10 =  -0.8056f ;
    fp32 p01 = 3.192f ;
    fp32 p20 = 3.381f ;
    fp32 p11 = 5.643f ;
    fp32 p02 =-13.29f ;
    fp32 p30 = 18.86f ;
    fp32 p21 =-25.66f ;
    fp32 p12 =-15.27f ;
    fp32 p03 = 25.98f ;
    fp32 p40 = 2.884f ;
    fp32 p31 =-71.75f ;
    fp32 p22 =  41.4f ;
    fp32 p13 = 16.83f ;
    fp32 p04 =-23.57f ;
    fp32 J2;
    fp32 x=0;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.3;
    else if(h>0.3)h=0.3;

    J2 = (p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
          + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
          + p13*x*h*h*h + p04*h*h*h*h);
    return J2;
}
fp32 VMC_solve_invJ2(fp32 a,fp32 h)
{
    fp32 p00 =       46.51 ;
    fp32 p10 =       252.7 ;
    fp32 p01 =      -666.5 ;
    fp32 p20 =       16.58 ;
    fp32 p11 =       -3169 ;
    fp32 p02 =        4117 ;
    fp32 p30 =       -1346 ;
    fp32 p21 =      -271.1 ;
    fp32 p12 =   1.358e+04 ;
    fp32 p03 =   -1.17e+04 ;
    fp32 p40 =      -583.1 ;
    fp32 p31 =        5547 ;
    fp32 p22 =        1172 ;
    fp32 p13 =  -1.986e+04 ;
    fp32 p04 =   1.288e+04 ;
    fp32 J2;
    fp32 x=0;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.12f;
    else if(h>0.3)h=0.3;

    J2 = (p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
          + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
          + p13*x*h*h*h + p04*h*h*h*h);
    return J2;
}


fp32 VMC_solve_J3(fp32 a,fp32 h)
{
    fp32   p00 = -0.1007;
    fp32	 p10 =   11.61f ;
    fp32	 p01 =   7.412f  ;
    fp32	 p20 =   12.82f  ;
    fp32	 p11 =    -135.6f  ;
    fp32	 p02 =   -43.23f;
    fp32	 p30 =   -100.2f ;
    fp32	 p21 =  -105.5f ;
    fp32	 p12 =   550.1f ;
    fp32	 p03 =   118.5f ;
    fp32	 p40 =  -6.175f ;
    fp32	 p31 =  407.0f  ;
    fp32	 p22 =   218.5f  ;
    fp32	 p13 =   -778.6f ;
    fp32	 p04 =  -129.3f ;
    fp32 J3;
    fp32 x=0;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.12f;
    else if(h>0.3)h=0.3;
    J3 = p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
         + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
         + p13*x*h*h*h + p04*h*h*h*h;
    return J3;
}

fp32 VMC_solve_invJ3(fp32 a,fp32 h)
{
    fp32 p00 =       3.724;
    fp32 p10 =      -31.85;
    fp32 p01 =       -39.7;
    fp32 p20 =       13.23;
    fp32 p11 =       354.5;
    fp32 p02 =       247.3;
    fp32 p30 =       298.6;
    fp32 p21 =      -132.5;
    fp32 p12 =       -1423;
    fp32 p03 =      -706.1;
    fp32 p40 =      -107.8;
    fp32 p31 =       -1193;
    fp32 p22 =       325.6;
    fp32 p13 =        1994;
    fp32 p04 =         778;
    fp32 J3;
    fp32 x=0;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.12f;
    else if(h>0.3)h=0.3;
    J3 = p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
         + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
         + p13*x*h*h*h + p04*h*h*h*h;
    return J3;
}
fp32 VMC_solve_J4(fp32 a,fp32 h)
{
    fp32   p00 =  -0.08806;
    fp32	 p10 =  -11.61  ;
    fp32	 p01 =   7.147  ;
    fp32	 p20 =   12.88  ;
    fp32	 p11 =   135.6 ;
    fp32	 p02 =  -41.17  ;
    fp32	 p30 =   100.6 ;
    fp32	 p21 =  -106.2 ;
    fp32	 p12 =  -550.1 ;
    fp32	 p03 =   111.4 ;
    fp32	 p40 =  -7.211 ;
    fp32	 p31 =  -408.9  ;
    fp32	 p22 =   220.5  ;
    fp32	 p13 =   778.5 ;
    fp32	 p04 =  -120.4 ;
    fp32 J4;
    fp32 x;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.12f;
    else if(h>0.3)h=0.3;
    J4 = p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
         + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
         + p13*x*h*h*h + p04*h*h*h*h;
    return J4;
}

fp32 VMC_solve_invJ4(fp32 a,fp32 h)
{
    fp32 p00 =       3.723;
    fp32 p10 =       31.86;
    fp32 p01 =      -39.68;
    fp32 p20 =       13.22;
    fp32 p11 =      -354.5;
    fp32 p02 =       247.1;
    fp32 p30 =      -298.6;
    fp32 p21 =      -132.4;
    fp32 p12 =        1423;
    fp32 p03 =      -705.6;
    fp32 p40 =        -108;
    fp32 p31 =        1193;
    fp32 p22 =       325.4;
    fp32 p13 =       -1995;
    fp32 p04 =       777.4;
    fp32 J4;
    fp32 x;
    x = h*arm_sin_f32(PI_2-a);
    h = h*arm_cos_f32(PI_2-a);
    if(x<-0.2f)x=-0.2f;
    else if(x>0.2f)x=0.2f;
    if(h<0.12f)h=0.12f;
    else if(h>0.3f)h=0.3f;
    J4 = p00 + p10*x + p01*h + p20*x*x + p11*x*h + p02*h*h + p30*x*x*x + p21*x*x*h
         + p12*x*h*h + p03*h*h*h + p40*x*x*x*x + p31*x*x*x*h + p22*x*x*h*h
         + p13*x*h*h*h + p04*h*h*h*h;
    return J4;
}